module SkelBNF where

-- Haskell module generated by the BNF converter

import AbsBNF
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transLGrammar :: LGrammar -> Result
transLGrammar x = case x of
  LGr ldefs -> failure x
transLDef :: LDef -> Result
transLDef x = case x of
  DefAll def -> failure x
  DefSome idents def -> failure x
  LDefView idents -> failure x
transGrammar :: Grammar -> Result
transGrammar x = case x of
  Grammar defs -> failure x
transDef :: Def -> Result
transDef x = case x of
  Rule label cat items -> failure x
  Comment string -> failure x
  Comments string1 string2 -> failure x
  Internal label cat items -> failure x
  Token ident reg -> failure x
  PosToken ident reg -> failure x
  Entryp idents -> failure x
  Separator minimumsize cat string -> failure x
  Terminator minimumsize cat string -> failure x
  Delimiters cat string1 string2 separation minimumsize -> failure x
  Coercions ident integer -> failure x
  Rules ident rhss -> failure x
  Function ident args exp -> failure x
  Layout strings -> failure x
  LayoutStop strings -> failure x
  LayoutTop -> failure x
transItem :: Item -> Result
transItem x = case x of
  Terminal string -> failure x
  NTerminal cat -> failure x
transCat :: Cat -> Result
transCat x = case x of
  ListCat cat -> failure x
  IdCat ident -> failure x
transLabel :: Label -> Result
transLabel x = case x of
  LabNoP labelid -> failure x
  LabP labelid profitems -> failure x
  LabPF labelid1 labelid2 profitems -> failure x
  LabF labelid1 labelid2 -> failure x
transLabelId :: LabelId -> Result
transLabelId x = case x of
  Id ident -> failure x
  Wild -> failure x
  ListE -> failure x
  ListCons -> failure x
  ListOne -> failure x
transProfItem :: ProfItem -> Result
transProfItem x = case x of
  ProfIt intlists integers -> failure x
transIntList :: IntList -> Result
transIntList x = case x of
  Ints integers -> failure x
transSeparation :: Separation -> Result
transSeparation x = case x of
  SepNone -> failure x
  SepTerm string -> failure x
  SepSepar string -> failure x
transArg :: Arg -> Result
transArg x = case x of
  Arg ident -> failure x
transExp :: Exp -> Result
transExp x = case x of
  Cons exp1 exp2 -> failure x
  App ident exps -> failure x
  Var ident -> failure x
  LitInt integer -> failure x
  LitChar char -> failure x
  LitString string -> failure x
  LitDouble double -> failure x
  List exps -> failure x
transRHS :: RHS -> Result
transRHS x = case x of
  RHS items -> failure x
transMinimumSize :: MinimumSize -> Result
transMinimumSize x = case x of
  MNonempty -> failure x
  MEmpty -> failure x
transReg :: Reg -> Result
transReg x = case x of
  RSeq reg1 reg2 -> failure x
  RAlt reg1 reg2 -> failure x
  RMinus reg1 reg2 -> failure x
  RStar reg -> failure x
  RPlus reg -> failure x
  ROpt reg -> failure x
  REps -> failure x
  RChar char -> failure x
  RAlts string -> failure x
  RSeqs string -> failure x
  RDigit -> failure x
  RLetter -> failure x
  RUpper -> failure x
  RLower -> failure x
  RAny -> failure x

