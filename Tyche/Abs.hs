

module Tyche.Abs where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Program a (Stmt a)
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a stmt -> Program (f a) (fmap f stmt)
data Arg a = Arg a (ArgMod a) (FullIdent a) (FullType a)
  deriving (Eq, Ord, Show, Read)

instance Functor Arg where
    fmap f x = case x of
        Arg a argmod fullident fulltype -> Arg (f a) (fmap f argmod) (fmap f fullident) (fmap f fulltype)
data FullIdent a = FullIdent a Ident | AnonIdent a
  deriving (Eq, Ord, Show, Read)

instance Functor FullIdent where
    fmap f x = case x of
        FullIdent a ident -> FullIdent (f a) ident
        AnonIdent a -> AnonIdent (f a)
data Stmt a
    = Skip a
    | Break a
    | Continue a
    | Ret a (Expr a)
    | VRet a
    | VarDef a (FullIdent a) (FullType a) (Expr a)
    | Ass a Ident (Expr a)
    | FnDef a (FullIdent a) (FullType a) [Arg a] (Stmt a)
    | Cond a (Expr a) (Stmt a)
    | CondElse a (Expr a) (Stmt a) (Stmt a)
    | While a (Expr a) (Stmt a)
    | ForList a Ident (Expr a) (Stmt a)
    | ForRange a Ident (Expr a) (Expr a) (Stmt a)
    | Composition a (Stmt a) (Stmt a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        Skip a -> Skip (f a)
        Break a -> Break (f a)
        Continue a -> Continue (f a)
        Ret a expr -> Ret (f a) (fmap f expr)
        VRet a -> VRet (f a)
        VarDef a fullident fulltype expr -> VarDef (f a) (fmap f fullident) (fmap f fulltype) (fmap f expr)
        Ass a ident expr -> Ass (f a) ident (fmap f expr)
        FnDef a fullident fulltype args stmt -> FnDef (f a) (fmap f fullident) (fmap f fulltype) (map (fmap f) args) (fmap f stmt)
        Cond a expr stmt -> Cond (f a) (fmap f expr) (fmap f stmt)
        CondElse a expr stmt1 stmt2 -> CondElse (f a) (fmap f expr) (fmap f stmt1) (fmap f stmt2)
        While a expr stmt -> While (f a) (fmap f expr) (fmap f stmt)
        ForList a ident expr stmt -> ForList (f a) ident (fmap f expr) (fmap f stmt)
        ForRange a ident expr1 expr2 stmt -> ForRange (f a) ident (fmap f expr1) (fmap f expr2) (fmap f stmt)
        Composition a stmt1 stmt2 -> Composition (f a) (fmap f stmt1) (fmap f stmt2)
data Type a
    = Int a
    | Str a
    | Bool a
    | Void a
    | Float a
    | List a (FullType a)
    | Array a (FullType a)
    | Fun a [ArgType a] (FullType a)
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        Int a -> Int (f a)
        Str a -> Str (f a)
        Bool a -> Bool (f a)
        Void a -> Void (f a)
        Float a -> Float (f a)
        List a fulltype -> List (f a) (fmap f fulltype)
        Array a fulltype -> Array (f a) (fmap f fulltype)
        Fun a argtypes fulltype -> Fun (f a) (map (fmap f) argtypes) (fmap f fulltype)
data ArgType a = ArgType a (ArgMod a) (FullType a)
  deriving (Eq, Ord, Show, Read)

instance Functor ArgType where
    fmap f x = case x of
        ArgType a argmod fulltype -> ArgType (f a) (fmap f argmod) (fmap f fulltype)
data FullType a = FullType a [TypeMod a] (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor FullType where
    fmap f x = case x of
        FullType a typemods type_ -> FullType (f a) (map (fmap f) typemods) (fmap f type_)
data ArgMod a = AModVar a | AModVal a | AModInOut a
  deriving (Eq, Ord, Show, Read)

instance Functor ArgMod where
    fmap f x = case x of
        AModVar a -> AModVar (f a)
        AModVal a -> AModVal (f a)
        AModInOut a -> AModInOut (f a)
data TypeMod a = TModReadonly a
  deriving (Eq, Ord, Show, Read)

instance Functor TypeMod where
    fmap f x = case x of
        TModReadonly a -> TModReadonly (f a)
data Expr a
    = EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EString a String
    | ELitFloat a Double
    | EEmpList a (FullType a)
    | EApp a (Expr a) [Expr a]
    | Neg a (Expr a)
    | Not a (Expr a)
    | ECons a (Expr a) (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (AndOp a) (Expr a)
    | EOr a (Expr a) (OrOp a) (Expr a)
    | EList a [Expr a]
    | EArr a [Expr a]
    | EArrSize a (FullType a) (Expr a)
    | EArrApp a (Expr a) (Expr a)
    | EIf a (Expr a) (Expr a) (Expr a)
    | ELambda a (FullType a) [Arg a] (Stmt a)
    | ERand a (Expr a)
    | ERandDist a (Expr a) (Expr a)
    | EProb a (Stmt a) (Expr a)
    | EProbSamp a (Expr a) (Stmt a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EString a string -> EString (f a) string
        ELitFloat a double -> ELitFloat (f a) double
        EEmpList a fulltype -> EEmpList (f a) (fmap f fulltype)
        EApp a expr exprs -> EApp (f a) (fmap f expr) (map (fmap f) exprs)
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        ECons a expr1 expr2 -> ECons (f a) (fmap f expr1) (fmap f expr2)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 andop expr2 -> EAnd (f a) (fmap f expr1) (fmap f andop) (fmap f expr2)
        EOr a expr1 orop expr2 -> EOr (f a) (fmap f expr1) (fmap f orop) (fmap f expr2)
        EList a exprs -> EList (f a) (map (fmap f) exprs)
        EArr a exprs -> EArr (f a) (map (fmap f) exprs)
        EArrSize a fulltype expr -> EArrSize (f a) (fmap f fulltype) (fmap f expr)
        EArrApp a expr1 expr2 -> EArrApp (f a) (fmap f expr1) (fmap f expr2)
        EIf a expr1 expr2 expr3 -> EIf (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        ELambda a fulltype args stmt -> ELambda (f a) (fmap f fulltype) (map (fmap f) args) (fmap f stmt)
        ERand a expr -> ERand (f a) (fmap f expr)
        ERandDist a expr1 expr2 -> ERandDist (f a) (fmap f expr1) (fmap f expr2)
        EProb a stmt expr -> EProb (f a) (fmap f stmt) (fmap f expr)
        EProbSamp a expr1 stmt expr2 -> EProbSamp (f a) (fmap f expr1) (fmap f stmt) (fmap f expr2)
data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)
data OrOp a = Or a
  deriving (Eq, Ord, Show, Read)

instance Functor OrOp where
    fmap f x = case x of
        Or a -> Or (f a)
data AndOp a = And a
  deriving (Eq, Ord, Show, Read)

instance Functor AndOp where
    fmap f x = case x of
        And a -> And (f a)
