-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrammar where
import AbsGrammar
import LexGrammar
import ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pExpr6_internal Expr6
%name pExpr5_internal Expr5
%name pExpr4_internal Expr4
%name pExpr3_internal Expr3
%name pExpr2_internal Expr2
%name pExpr1_internal Expr1
%name pExpr_internal Expr
%name pListExpr_internal ListExpr
%name pAddOp_internal AddOp
%name pMulOp_internal MulOp
%name pRelOp_internal RelOp
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&&' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '+' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '<=' { PT _ (TS _ 13) }
  '==' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  'false' { PT _ (TS _ 17) }
  'true' { PT _ (TS _ 18) }
  '||' { PT _ (TS _ 19) }

  L_ident {PT _ (TV _)}
  L_integ {PT _ (TI _)}
  L_quoted {PT _ (TL _)}

%%

Ident :: {
  (Maybe (Int, Int), Ident)
}
: L_ident {
  (Just (tokenLineCol $1), Ident (prToken $1)) 
}

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

String :: {
  (Maybe (Int, Int), String)
}
: L_quoted {
  (Just (tokenLineCol $1), prToken $1)
}

Expr6 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Ident {
  (fst $1, AbsGrammar.EVar (fst $1)(snd $1)) 
}
| Integer {
  (fst $1, AbsGrammar.ELitInt (fst $1)(snd $1)) 
}
| 'true' {
  (Just (tokenLineCol $1), AbsGrammar.ELitTrue (Just (tokenLineCol $1)))
}
| 'false' {
  (Just (tokenLineCol $1), AbsGrammar.ELitFalse (Just (tokenLineCol $1)))
}
| Ident '(' ListExpr ')' {
  (fst $1, AbsGrammar.EApp (fst $1)(snd $1)(snd $3)) 
}
| String {
  (fst $1, AbsGrammar.EString (fst $1)(snd $1)) 
}
| '(' Expr ')' {
  (Just (tokenLineCol $1), snd $2)
}

Expr5 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: '-' Expr6 {
  (Just (tokenLineCol $1), AbsGrammar.Neg (Just (tokenLineCol $1)) (snd $2)) 
}
| '!' Expr6 {
  (Just (tokenLineCol $1), AbsGrammar.Not (Just (tokenLineCol $1)) (snd $2)) 
}
| Expr6 {
  (fst $1, snd $1)
}

Expr4 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr4 MulOp Expr5 {
  (fst $1, AbsGrammar.EMul (fst $1)(snd $1)(snd $2)(snd $3)) 
}
| Expr5 {
  (fst $1, snd $1)
}

Expr3 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr3 AddOp Expr4 {
  (fst $1, AbsGrammar.EAdd (fst $1)(snd $1)(snd $2)(snd $3)) 
}
| Expr4 {
  (fst $1, snd $1)
}

Expr2 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr2 RelOp Expr3 {
  (fst $1, AbsGrammar.ERel (fst $1)(snd $1)(snd $2)(snd $3)) 
}
| Expr3 {
  (fst $1, snd $1)
}

Expr1 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr2 '&&' Expr1 {
  (fst $1, AbsGrammar.EAnd (fst $1)(snd $1)(snd $3)) 
}
| Expr2 {
  (fst $1, snd $1)
}

Expr :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr1 '||' Expr {
  (fst $1, AbsGrammar.EOr (fst $1)(snd $1)(snd $3)) 
}
| Expr1 {
  (fst $1, snd $1)
}

ListExpr :: {
  (Maybe (Int, Int), [Expr (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Expr {
  (fst $1, (:[]) (snd $1)) 
}
| Expr ',' ListExpr {
  (fst $1, (:) (snd $1)(snd $3)) 
}

AddOp :: {
  (Maybe (Int, Int), AddOp (Maybe (Int, Int)))
}
: '+' {
  (Just (tokenLineCol $1), AbsGrammar.Plus (Just (tokenLineCol $1)))
}
| '-' {
  (Just (tokenLineCol $1), AbsGrammar.Minus (Just (tokenLineCol $1)))
}

MulOp :: {
  (Maybe (Int, Int), MulOp (Maybe (Int, Int)))
}
: '*' {
  (Just (tokenLineCol $1), AbsGrammar.Times (Just (tokenLineCol $1)))
}
| '/' {
  (Just (tokenLineCol $1), AbsGrammar.Div (Just (tokenLineCol $1)))
}
| '%' {
  (Just (tokenLineCol $1), AbsGrammar.Mod (Just (tokenLineCol $1)))
}

RelOp :: {
  (Maybe (Int, Int), RelOp (Maybe (Int, Int)))
}
: '<' {
  (Just (tokenLineCol $1), AbsGrammar.LTH (Just (tokenLineCol $1)))
}
| '<=' {
  (Just (tokenLineCol $1), AbsGrammar.LE (Just (tokenLineCol $1)))
}
| '>' {
  (Just (tokenLineCol $1), AbsGrammar.GTH (Just (tokenLineCol $1)))
}
| '>=' {
  (Just (tokenLineCol $1), AbsGrammar.GE (Just (tokenLineCol $1)))
}
| '==' {
  (Just (tokenLineCol $1), AbsGrammar.EQU (Just (tokenLineCol $1)))
}
| '!=' {
  (Just (tokenLineCol $1), AbsGrammar.NE (Just (tokenLineCol $1)))
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens

pExpr6 = (>>= return . snd) . pExpr6_internal
pExpr5 = (>>= return . snd) . pExpr5_internal
pExpr4 = (>>= return . snd) . pExpr4_internal
pExpr3 = (>>= return . snd) . pExpr3_internal
pExpr2 = (>>= return . snd) . pExpr2_internal
pExpr1 = (>>= return . snd) . pExpr1_internal
pExpr = (>>= return . snd) . pExpr_internal
pListExpr = (>>= return . snd) . pListExpr_internal
pAddOp = (>>= return . snd) . pAddOp_internal
pMulOp = (>>= return . snd) . pMulOp_internal
pRelOp = (>>= return . snd) . pRelOp_internal
}

